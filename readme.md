

# TinyWebServer

## 项目简介：

本项目是制作的一个简单的Linux系统服务器项目，涉及到的知识点包括网络编程，Linux系统使用，服务器性能调优，C/C++编程，计算机网络等多个领域的知识，同时本项目是我第一次对一个项目进行系统测试，找到了项目的弊端并基于了修正，程序的健壮性和可维护性有了进一步的提高。

下面是我所做的一些主要工作

- 使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) 的并发模型
- 使用状态机解析HTTP请求报文，支持解析GET和POST请求
- 访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件
- 实现同步/异步日志系统，记录服务器运行状态
- 经Webbench压力测试可以实现上万的并发连接数据交换

## 项目难点：
  难点主要有两个，一个是并发模型和网络模式的选择，另一个是服务器性能上的调优。
  
### 并发模型和网络模式的选择
  让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。。而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。
  一个线程要处理多个连接的业务，线程在处理某个连接的 read 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。要解决这一个问题，最简单的方式就是将 socket 改成非阻塞，然后线程不断地轮询调用 read 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。
  只有当连接上有数据的时候，线程才去发起读请求呢？这就是IO多路复用，他可以在一个进程中监听多个socket文件的IO，Linux有三种基于IO多路复用的API，分别是select、poll和epoll。
  IO多路复用很少有直接使用的，通常都会在他的基础上进行封装，所以就有了两种不同的网络模式：Reactor和Proactor。
  Reactor模式由主线程和工作线程组成，主线程负责监听连接和分配任务，工作线程负责处理读写数据和建立连接。
  Proactor模式和Reactor模式类似，只不过他是基于异步IO实现的的网络模型，数据的读写都是有操作系统自动完成的。
  我对两种方式都做了不同的实现，Proactor模式由于Linux下不支持基于Socket的异步IO，所以这里使用同步IO实现，结果说明Proactor效率明显由于Reactor。
#### 有关三种不同的IO多路复用技术
  select和poll并没有本质区别，都是使用线性结构存储关注的socket集合。
  
  在使用时，首先需要将socket集合从用户态传入到内核缓冲区中，由操作系统将由事件发生的文件描述符置为可读或者可写，然后在传到应用程序中，通过遍历socket集合判断哪些文件描述符上由有事件发生。可以看到整个过程中发生了两次集合的遍历和拷贝，并且效率随着连接的增多有着显著降低。所以这两种方式效率较低。
  
  epoll通过两方面解决了这方面的问题：
  1.epoll在内核中使用红黑树关注待检测的Socket集合，红黑树是一个高效的数据结构，增删查改的时间复杂度都在O(logn)，基于此我们不需要每次传入整个Socket集合，减少了内核空间与用户空间大量的数据拷贝。
  2.epoll使用事件驱动的机制，内核中维护一个链表记录就绪时间，每次只需要将有事件发生的Socket集合传递给应用程序，不需要扫描整个集合。
  3.epoll支持边缘触发和水平触发，而select和poll只支持水平触发，边缘触发的效率一般要比水平触发要高很多。

### 服务器性能调优

  使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，由于同步模式写入日志可能导致线程阻塞，降低性能，所以使用异步写入的方式进行改进。具体地，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。
  
  使用定时器处理非活动连接，为每一个连接创建一个定时器，使用升序链表将定时器串联起来，使用ALARM函数触发SIGALRM信号，执行信号处理函数，在信号处理函数中关闭连接。
  (但是由于信号处理函数和当前线程是两条不同的执行流程。在进程收到信号后，操作系统会中断当前流程，保存上下文环境，再去执行信号处理函数，最后返回中断的地方重新执行。为避免信号竞态现象发生，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽可能快地执行完毕。这里采用统一事件源的方式解决。
  统一事件源，是指将信号事件与其他事件一样被处理。具体的，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I/O复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来监测，从而实现统一处理。)
  
  和线程池类似，使用数据库连接池实现了数据库连接的复用，避免每次使用数据库连接都要动态分配。数据库连接池底层封装了生产者消费者模型，以C++模板库中的链表作为阻塞队列，使用信号量和互斥锁保证线程安全的问题。
  
  对于项目中可能产生的内存泄漏和野指针问题，这里使用RAII思想对部分类进行封装。RAII即资源获取即初始化，他的核心思想是利用栈上局部变量离开作用域自动析构保证资源一定会被释放。在实现上，我们需要先设计一个类争创资源，在构造函数中分配资源，在析构函数中释放类的资源，将其在函数开始时进行声明。智能指针的实现借助于RAII的思想。
  
## 项目的缺点和不足：
  
  两方面的不足，一个是为了保证线程安全，线程池中频繁地加锁解锁会导致整体的运行效率降低，可以考虑使用协程进行优化，因为协程有三个优势：上下文切换开销小，轻量级资源消耗少，不需要进行同步。
  
  还有一个是线程池数量设置为固定，在不同机器部署上性能差异会比较明显，可以通过检测CPU以及内存占用情况，动态创建新的线程，或者根据C++ 17引入的std:thread_hardware_concurrency系统调用动态获得系统核数，据此来分配线程数量。
  
## Demo演示

### 注册演示

![注册演示](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/ef83ba53-5c4d-49a4-9151-a8222d419307)

### 登录演示

![登录演示](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/27e2a483-9620-4359-940f-4ce38b802055)


### 请求图片文件演示

![请求图片演示](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/29ae889a-ec9f-43e1-b331-4f93adfdafcf)

### 请求视频文件演示

![请求视频演示](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/dbcf2036-fa45-4a56-a757-cfad37b7457a)

## 测试环节

本项目的测试包括功能测试，性能测试，安全性测试，兼容性测试和易用性测试以及UI测试六部分。主要的测试目标在于项目的登录和注册以及访问资源这两项和核心功能。下图是我绘制的测试用例的一份思维导图。

![Webserver测试用例](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/74766295-5fd8-44db-8156-236fcf17424a)

### 功能测试

对于功能测试、兼容性测试以及安全性测试的测试用例，我使用了web端自动化测试工具selenuim搭配pytest自动化测试框架实现，同时采用了yaml文件实现数据驱动。在完成首次测试目标后，使用PO设计模式对其进行封装。

> PO是Page Object的缩写，PO模式是自动化测试项目开发实践的最佳设计模式之一。 核心思想是通过对界面元素的封装减少冗余代码，同时在后期维护中，若元素定位发生变化， 只 需要调整页面元素封装的代码，提高测试用例的可维护性、可读性。 

本项目使用PO模式可以把一个页面分为三层，对象库层、操作层、业务层。分别实现其相应的功能。

- 对象库层：封装定位元素的方法。 
- 操作层：封装对元素的操作。
- 业务层：将一个或多个操作组合起来完成一个业务功能。比如登录：需要输入帐号、密码、点 击登录三个操作。

### 接口测试

接口测试主要针对页面跳转的情况，对其返回的结果进行断言，判断各种情况下页面能够正常跳转到正常的页面。

### 测试报告

接口测试结果：

![接口测试结果](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/62705229-6c32-4c7f-bf38-c6acaa782dbf)

登录功能测试结果：

![登录UI自动化测试结果](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/c79f7146-5eb4-4e91-98b1-cc12cee6103e)

注册功能测试结果：

![注册UI自动化测试结果](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/7cba5515-9a06-4221-99fa-4f441a088541)

采用allure插件输出测试报告：

![allure测试报告](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/52d8a97e-da8b-4952-a533-00ba31f4e094)

### 压力测试

压力测试是专门的一个模块，对于Web项目，通常比较关心并发量和响应时间这两个性能指标。

有关浏览器响应时间的测试，可以根据浏览器的开发者模式中直接观察到具体结果，所有响应的耗时都在10ms以内，并发量提高响应时间并无明显变化。

![响应时间](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/1f0ef4ef-bcb1-47ef-87bc-d590ccaeb2ee)

有关并发量的测试，这里采用的工具是Webbench，使用起来非常简单。

在关闭日志后，使用Webbench对服务器进行压力测试，对监听的文件描述符分别采用ET和LT模式，测试结果如下：

LT模式测试结果：

![LT测试结果](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/273ba0a6-a118-4adc-af5e-6c0bcce19c13)

ET模式测试结果：

![ET测试结果](https://github.com/Lv-Yinghao/MyWebserver/assets/76142149/1f900478-5357-47de-8906-05a6eee97ff2)

可以发现相较于LT模式，ET模式的并发有明显提高。


